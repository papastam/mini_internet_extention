#!/usr/bin/env python3
# encoding: utf-8
"""
cache.py

Created by Thomas Mangin
Copyright (c) 2013-2017 Exa Networks. All rights reserved.
License: 3-clause BSD. (See the COPYRIGHT file)
"""

import os
import re
import sys
import json
import glob
import time
import signal
import argparse
import subprocess
from enum import Enum

INTERPRETER = os.environ.get('__PYVENV_LAUNCHER__', sys.executable)


class Alarm(Exception):
    pass


def alarm_handler(number, frame):  # pylint: disable=W0613
    raise Alarm()


def color(prefix, suffix):
    def code(value):
        return f'\033[{value}m'
    return code(prefix) + code(suffix)


class Port:
    base = 1790

    @classmethod
    def get(cls):
        current = cls.base
        cls.base += 1
        return current


class Path:
    PROGRAM = os.path.realpath(__file__)
    ROOT = os.path.abspath(os.path.join(os.path.dirname(PROGRAM), os.path.join('..', '..')))
    SRC = os.path.join(ROOT, 'src')

    ETC = os.path.join(ROOT, 'etc', 'exabgp')
    EXABGP = os.path.join(ROOT, 'sbin', 'exabgp')
    BGP = os.path.join(ROOT, 'qa', 'sbin', 'bgp')
    DECODING = os.path.join(os.path.join(ROOT, 'qa', 'decoding'))
    ENCODING = os.path.join(os.path.join(ROOT, 'qa', 'encoding'))

    ALL_ETC = glob.glob(os.path.join(ETC, '*.conf'))
    ALL_ETC.sort()
    ALL_DECODING = glob.glob(os.path.join(DECODING, '*'))
    ALL_DECODING.sort()
    ALL_ENCODING = glob.glob(os.path.join(ENCODING, '*.ci'))
    ALL_ENCODING.sort()

    @staticmethod
    def etc(fname):
        return os.path.abspath(os.path.join(Path.ETC, fname))

    @staticmethod
    def ci(fname, ext):
        return os.path.abspath(os.path.join(Path.ENCODING, fname) + '.' + ext)

    @classmethod
    def validate(cls):
        if not os.path.isdir(cls.ETC):
            sys.exit('could not find etc folder')

        if not os.path.isdir(cls.ENCODING):
            sys.exit('could not find tests in the qa/encoding folder')

        if not os.path.isdir(cls.DECODING):
            sys.exit('could not find the tests in qa/decoding')

        if not os.path.isfile(cls.EXABGP):
            sys.exit('could not find exabgp')

        if not os.path.isfile(cls.BGP):
            sys.exit('could not find the sequence daemon')


class Sequence:
    def __init__(self):
        self._next = 0

    def increase(self):
        self._next += 1
        return self._next - 1

    def current(self):
        return self._next


class Exec(object):
    def __init__(self):
        self.code = -1
        self.stdout = b''
        self.stderr = b''
        self._process = None
        self.command = []

    def run(self, command):
        self.command = ' '.join([_ if ' ' not in _ else f"'{_}'" for _ in command])
        self._process = subprocess.Popen(
            command,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )
        return self

    def ready(self):
        signal.signal(signal.SIGALRM, alarm_handler)
        try:
            signal.alarm(1)
            polled = self._process.poll()
            signal.alarm(0)
        except Alarm:
            return False
        except (OSError, ValueError):
            return True
        if polled is None:
            return False
        return True

    def failed(self, reason='issue with exabgp'):
        print(reason)
        print(f'> {self.command}')
        print(f'return: {self.code}')
        print(f'stdout: {self.stdout}')
        print(f'stderr: {self.stderr}')
        return False

    def collect(self):
        if self.stdout:
            return
        if self.stderr:
            return
        if self.code != -1:
            return

        signal.signal(signal.SIGALRM, alarm_handler)
        try:
            signal.alarm(5)
            self.stdout, self.stderr = self._process.communicate()
            self.code = self._process.returncode
            signal.alarm(0)
        except ValueError:  # I/O operation on closed file
            pass
        except Alarm:
            pass

    def terminate(self):
        try:
            self._process.send_signal(signal.SIGTERM)
        except OSError:  # No such process, Errno 3
            pass
        self.collect()

    def __del__(self):
        self.terminate


State = Enum('State', 'NONE STARTING RUNNING FAIL SUCCESS SKIP')


class Record:
    _listing = \
        '0123456789' + \
        'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + \
        'abcdefghijklmnopqrstuvwxyz' + \
        'αβγδεζηθικλμνξοπρςστυφχψω'

    def __init__(self, nick, name):
        self.nick = nick
        self.name = name
        self.conf = dict()
        self.files = []
        self.state = State.NONE

    @classmethod
    def new(cls, number, name):
        nick = cls._listing[number]
        return cls(nick, name)

    def skip(self):
        self.state = State.SKIP

    def activate(self, test):
        if test:
            self.state = State.NONE
            return self
        else:
            self.state = State.SKIP
            return None

    def is_active(self):
        return self.state not in (State.SKIP, State.FAIL, State.SUCCESS)

    def setup(self):
        if self.state == State.NONE:
            self.state = State.STARTING
            return
        if self.state == State.STARTING:
            self.state = State.RUNNING
            return

    def running(self):
        self.state = State.RUNNING

    def colored(self):
        if self.state == State.NONE:
            return color(0, 30) + self.nick  # BLACK
        if self.state == State.STARTING:
            return color(1, 30) + self.nick  # GRAY
        if self.state == State.RUNNING:
            return color(0, 0) + self.nick  # NORMAL
        if self.state == State.FAIL:
            return color(0, 91) + self.nick  # RED
        if self.state == State.SUCCESS:
            return color(1, 92) + '✓'        # GREEN
        if self.state == State.SKIP:
            return color(0, 34) + '✖'        # BLUE

    def result(self, success):
        if success:
            self.state = State.SUCCESS
        else:
            self.state = State.FAIL
        return success


class Tests:
    def __init__(self, klass):
        self.klass = klass
        self._sequence = Sequence()
        self._from_code = {}
        self._from_nick = {}
        self._nl = 3

    def new(self, name):
        code = self._sequence.increase()
        test = self.klass.new(code, name)
        self._from_code[code] = test
        self._from_nick[test.nick] = test
        return test

    def select(self, nick):
        if not nick:
            return None
        activated = None
        for test in self._from_code.values():
            activated = test.activate(test.nick == nick) or activated
        return activated

    def all(self):
        for test in self._from_code.values():
            test.state = State.SKIP

        for test in self._from_code.values():
            if test.state == State.SKIP:
                test.state = State.NONE
            test.result(self.run_active(parsed.timeout))

    def selected(self):
        return [_ for _ in self._from_code.values() if _.is_active()]

    def _iterate(self):
        last = self._sequence.current()
        step = last // self._nl
        if last % self._nl:
            step += 1
        nl = 1

        for c in range(0, step):
            for r in range(self._nl):
                n = c + (r*step)
                if n >= last:
                    return
                test = self._from_code[n]
                yield test.nick, test.name, not (nl % self._nl)
                nl += 1

    def listing(self):
        sys.stdout.write('\n')
        sys.stdout.write('The available tests are:\n')
        sys.stdout.write('\n')
        for nick, name, nl in self._iterate():
            sys.stdout.write(f' {nick:2} {name:25}')
            sys.stdout.write('\n' if nl else '')
        sys.stdout.write('\n')
        sys.stdout.flush()

    def display(self):
        for test in self._from_code.values():
            sys.stdout.write(' %s' % test.colored())
        sys.stdout.write('%s\r' % color(0, 0))
        sys.stdout.flush()


class EncodingTests(Tests):
    class Test(Record, Exec):
        def __init__(self, nick, name):
            Record.__init__(self, nick, name)
            Exec.__init__(self)
            self._check = b'successful'

        def success(self):
            self.collect()
            if self.code == 0:
                if self._check in self.stdout:
                    return True
                if self._check in self.stderr:
                    return True

            return self.failed()

    API = re.compile(r'^\s*run\s+(.*)\s*?;\s*?$')

    def __init__(self):
        super().__init__(self.Test)

        for filename in Path.ALL_ENCODING:
            name = os.path.basename(filename)[:-3]
            test = self.new(name)
            with open(filename, 'r') as reader:
                content = reader.readline()
            test.conf['confs'] = [Path.etc(_) for _ in content.split()]
            test.conf['ci'] = Path.ci(name, 'ci')
            test.conf['msg'] = Path.ci(name, 'msg')
            test.conf['port'] = Port.get()
            test.files.extend(test.conf['confs'])
            test.files.append(test.conf['ci'])
            test.files.append(test.conf['msg'])

            for f in test.conf['confs']:
                with open(f) as reader:
                    for line in reader:
                        found = self.API.match(line)
                        if not found:
                            continue
                        name = found.group(1)
                        if not name.startswith('/'):
                            name = Path.etc(name)
                        if name not in test.files:
                            test.files.append(name)

    def explain(self, index):
        template = '\n'
        template += 'exabgp\n'
        template += '-'*55 + '\n\n'
        template += '%(client)s\n\n\n'
        template += 'bgp deamon\n'
        template += '-'*55 + '\n\n'
        template += '%(server)s\n\n\n'
        template += 'The following extra configuration options could be used\n'
        template += '-'*55 + '\n\n'
        template += 'export exabgp_debug_rotate=true\n'
        template += 'export exabgp_debug_defensive=true\n'

        print(template % {
            'client': self.client(index),
            'server': self.server(index),
        })

    def client(self, index):
        test = self.select(index)
        if not test:
            sys.exit("no such test")

        config = {
            'env': ' \\\n  '.join(
                [
                    'exabgp_tcp_once=true',
                    'exabgp_api_cli=false',
                    'exabgp_debug_rotate=true',
                    'exabgp_debug_configuration=true',
                    'exabgp_tcp_bind=\'\'',
                    'exabgp_tcp_port=%d' % test.conf['port'],
                    'INTERPRETER=%s' % INTERPRETER,
                ]
            ),
            'exabgp': Path.EXABGP,
            'confs': ' \\\n    '.join(test.conf['confs']),
        }
        return 'env \\\n  %(env)s \\\n   %(exabgp)s -d -p \\\n    %(confs)s' % config

    def server(self, index):
        test = self.select(index)

        if not test:
            sys.exit("no such test")

        config = {
            'env': ' \\\n  '.join(['exabgp_tcp_port=%d' % test.conf['port'],]),
            'interpreter': INTERPRETER,
            'bgp': Path.BGP,
            'msg': test.conf['msg'],
        }

        return 'env \\\n  %(env)s \\\n  %(interpreter)s %(bgp)s --view \\\n    %(msg)s' % config

    def dry(self):
        result = []
        for test in self.selected():
            result.append(' '.join([
                '>',
                sys.argv[0],
                'encoding', '--server', test.nick,
                '--port', f'{test.conf["port"]}'
            ]))
            result.append(' '.join([
                '>',
                sys.argv[0],
                'encoding', '--client', test.nick,
                '--port', f'{test.conf["port"]}'
            ]))
        return '\n'.join(result)

    def run_active(self, timeout):
        success = True
        client = dict()

        for test in self.selected():
            test.setup()
            self.display()
            test.run([
                sys.argv[0],
                'encoding', '--server', test.nick,
                '--port', f'{test.conf["port"]}'
            ])
            time.sleep(0.005)

        time.sleep(0.02)

        for test in self.selected():
            test.setup()
            self.display()
            client[test.nick] = Exec().run([
                sys.argv[0],
                'encoding', '--client', test.nick,
                '--port', f'{test.conf["port"]}'
            ])
            time.sleep(0.005)

        exit_time = time.time() + timeout

        running = set(test for test in self.selected())

        while running and time.time() < exit_time:
            self.display()
            for test in list(running):
                if not test.ready():
                    continue
                if not client[test.nick].ready():
                    continue
                running.remove(test)
                client[test.nick].terminate()
                success = test.result(test.success()) and success
                self.display()
            time.sleep(0.1)

        self.display()
        return success


class DecodingTests(Tests):
    class Test(Record, Exec):
        def __init__(self, nick, name):
            Record.__init__(self, nick, name)
            Exec.__init__(self)

        def _cleanup(self, decoded):
            decoded.pop('exabgp', None)
            decoded.pop('host', None)
            decoded.pop('pid', None)
            decoded.pop('ppid', None)
            decoded.pop('time', None)
            decoded.pop('version', None)
            return decoded

        def success(self):
            self.collect()
            if not self.stdout:
                return self.failed()
            if self.stderr:
                return self.failed()
            try:
                decoded = json.loads(self.stdout)
                self._cleanup(decoded)
            except Exception:
                return self.failed('issue, failed to decode the JSON')
            if decoded != self.conf['json']:
                failure = 'issue, JSON does not match'
                failure += f'\ndecoded : {decoded}\n'
                failure += f'\nexpected: {self.conf["json"]}'
                return self.failed(failure)
            return True

    def __init__(self):
        super().__init__(self.Test)

        for filename in Path.ALL_DECODING:
            name = os.path.basename(filename).split('.')[0]
            test = self.new(name)
            with open(filename, 'r') as reader:
                words = reader.readline().split()
                test.conf['type'] = '--' + words[0]
                test.conf['family'] = f'{words[1]} {words[2]}'
                packet = reader.readline().replace(' ', '').strip()
                test.conf['packet'] = packet
                expected = reader.readline().strip()
                decoded = json.loads(expected)
                test.conf['json'] = test._cleanup(decoded)
            test.files.append(filename)

    def listing(self):
        sys.stdout.write('\n')
        sys.stdout.write('The available tests are:\n')
        sys.stdout.write('\n')
        for nick, name, nl in self._iterate():
            sys.stdout.write(f' {nick:2} {name:25}')
            sys.stdout.write('\n' if nl else '')
        sys.stdout.write('\n')
        sys.stdout.flush()

    def dry(self):
        result = []
        for test in self.selected():
            result.append(' '.join([
                '>',
                Path.EXABGP,
                'decode', '-f', f"'{test.conf['family']}'", test.conf['type'],
                test.conf['packet']
            ]))
        return '\n'.join(result)

    def run_active(self, timeout):
        success = True

        for test in self.selected():
            test.running()
            self.display()
            test.run([
                Path.EXABGP,
                'decode', '-f', test.conf['family'], test.conf['type'],
                test.conf['packet']
            ])

        for test in self.selected():
            self.display()
            success = test.result(test.success()) and success
            time.sleep(0.05)

        exit_time = time.time() + timeout
        running = set(test for test in self.selected())

        while running and time.time() < exit_time:
            self.display()
            for test in list(running):
                if not test.ready():
                    continue
                running.remove(test)
                success = test.result(test.success()) and success
                self.display()
            time.sleep(0.1)

        self.display()
        return success


class ParsingTests(Tests):
    class Test(Record, Exec):
        def __init__(self, nick, name):
            Record.__init__(self, nick, name)
            Exec.__init__(self)

        def success(self):
            self.collect()
            if self.code != 0:
                return self.failed()

            return self.code == 0

    def __init__(self):
        super().__init__(self.Test)

        for filename in Path.ALL_ETC:
            name = os.path.basename(filename).split('.')[0]
            test = self.new(name)
            test.conf['fname'] = filename
            test.files.append(filename)

    def listing(self):
        sys.stdout.write('\n')
        sys.stdout.write('The available tests are:\n')
        sys.stdout.write('\n')
        for nick, name, nl in self._iterate():
            sys.stdout.write(f' {nick:2} {name:25}')
            sys.stdout.write('\n' if nl else '')
        sys.stdout.write('\n')
        sys.stdout.flush()

    def dry(self):
        result = []
        for test in self.selected():
            result.append(' '.join([
                '>',
                Path.EXABGP,
                'validate', '-nrv', test.conf['fname']
            ]))
        return '\n'.join(result)

    def run_active(self, timeout):
        success = True

        for test in self.selected():
            test.running()
            self.display()
            test.run([
                Path.EXABGP,
                'validate', '-nrv', test.conf['fname']
            ])
            time.sleep(0.05)

        time.sleep(0.2)

        exit_time = time.time() + timeout
        running = set(test for test in self.selected())

        while running and time.time() < exit_time:
            self.display()
            for test in list(running):
                if not test.ready():
                    continue
                running.remove(test)
                success = test.result(test.success()) and success
                self.display()
            time.sleep(0.1)

        self.display()
        return success


def add_test(subparser, name, tests, extra):
    sub = subparser.add_parser(name, help=f'run {name} test')
    if 'dry' in extra:
        sub.add_argument('--dry', help='show the action', action='store_true')
    if 'server' in extra:
        sub.add_argument('--server', help='start the server for a test', action='store_true')
    if 'client' in extra:
        sub.add_argument('--client', help='start the client for a test', action='store_true')
    if 'list' in extra:
        sub.add_argument('--list', help='list the files making a test', action='store_true')
    if 'edit' in extra:
        sub.add_argument('--edit', help='edit the files making a test', action='store_true')
    if 'timeout' in extra:
        sub.add_argument('--timeout', help='timeout for test failure', type=int, default=60)
    if 'port' in extra:
        sub.add_argument('--port', help='base port to use', type=int, default=1790)
    sub.add_argument('test', help='name of the test to run', nargs='?', default=None)

    def func(parsed):
        if 'edit' in extra and parsed.edit:
            test = tests.select(parsed.test) or Record('', '')
            if not test.files:
                sys.exit('no such test')
            editor = os.environ.get('EDITOR', 'vi')
            command = '%s %s' % (editor, ' '.join(test.files))
            print(f'> {command}')
            if not parsed.dry:
                sys.exit(os.system(command))
            return

        if 'list' in extra and parsed.list:
            tests.listing()
            return

        if 'client' in extra and parsed.client:
            command = tests.client(parsed.test)
            print(f'> {command}')
            if not parsed.dry:
                sys.exit(os.system(command))
            return

        if 'server' in extra and parsed.server:
            command = tests.server(parsed.test)
            print(f'> {command}')
            if not parsed.dry:
                sys.exit(os.system(command))
            return

        if 'timeout' not in parsed:
            parsed.timeout = 0
        tests.select(parsed.test)
        if parsed.dry:
            command = tests.dry()
            print(command)
            sys.exit(0)
        exit = tests.run_active(parsed.timeout)
        sys.stdout.write('\n')
        sys.exit(0 if exit else 1)

    sub.set_defaults(func=func)


if __name__ == '__main__':
    Path.validate()

    decoding = DecodingTests()
    encoding = EncodingTests()
    parsing = ParsingTests()

    parser = argparse.ArgumentParser(description='The BGP swiss army knife of networking functional testing tool')
    subparser = parser.add_subparsers()

    add_test(subparser, 'decoding', decoding, ['list', 'edit', 'dry', 'timeout', 'port'])
    add_test(subparser, 'encoding', encoding, ['list', 'edit', 'dry', 'timeout', 'port', 'server', 'client'])
    add_test(subparser, 'parsing', parsing, ['list', 'dry', 'edit'])

    parsed = parser.parse_args()
    if vars(parsed):
        parsed.func(parsed)
    else:
        parser.print_help()
